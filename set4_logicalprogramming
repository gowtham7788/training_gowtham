Solutions:
1)  Because in UNIX size of int is 4 bytes.
  But in PC ,size of int is 2 bytes. So it can't hold the value above 32,767.
  The result will be the garbage value when run on PC.
  
2)  Because both 1 and 3 are int type.
  int/int =int.
  If we change any one of them into foat ,it gives the required output.
  
3)  Because the comment opens in the first line didn't close.
  So it takes the second line also a comment.
  
4)  Because array[2,4] is not have the valid index.

5)  C) It's compiler dependent.

6)  Auto:
      "auto" is the default storage class for all local variables.
      "auto" can only be used with in functions.
    Register:
       "register" is used to define local variables that should be stored
    in a register instead of RAM.
       It does not have a memory location ,So the unary '&' operator can't
    applied to it.
    Static:
        "static" is the default storage class for global variables.
        Static can also be defined with in a function. If this is done the 
    variable is initialized at run time but is not reinitialized when the 
    function is called.
    Extern:
        "extern" is used to give a reference of a global variable that is 
    visible to all the program files.
        When we use extern the variable cannot be initialized as all it does
    is point the variable name at a storage location that has been previously
    defined.

7)  Because the value for "zip" variable starts with 0. So it takes it as
  the octal valueand when we print it prints the decimal value for its 
  octal value.
  
8)  Yes ,it is a legal code.
    In order (2).
    
9)  We can change the value of ch between 48 and 57. Because it is the ASCII 
  value of from 0 to 9. So it can print the interger value between 0 and 9.
  
10) Because in "if" condition the assignment operator is used instead of 
  equality operator. So it can assign '0' to balance_owed variable and 
  takes the condition as false because of '0' then automatically else
  part will executed.
  
11) Because a semicolon is placed at the for loop. So the for loop will end 
  with single line. Then the for loop will perform increment value of "celsius"
  variable and check the condition repeatly. The condition is false when the
  "celsius" value is 101. So that it prints the corresponding fahrenheit value
  for celsius value 101.
  
12) The variable "data[5]" has the memory to store value from data[0] to data[4].
  In program we get the value for data[5]. So that value can be stored in the 
  address of "three_count" variable because the declaration after the variable
  data[5]. This is the reason for the wrong output.
  
13) The statement ALL_PART*ALL_PART takes the value as 7+5*7+5.
  Because ALL_PART is defined as FIRST_PART+LAST_PART.
  Now according to BODMAS it can be evaluated.
  7+5*7+5 = 7+35+5
          =47
   
14) 

15) C++ is a case sensitive language. The variable "SIZE" has the value 10 and 
  FUDGE has 8. We assign the FUDGE value to variable "size" , so it will print 
  the value 8.
  
16) By default "if" condition takes only one statement if curly braces is not given.
  In the program "DIE" has two statement ,when variable "value" got positive value
  it ignore the "if" statement (ie) in DIE the first statement (cerr<<"Fatal Error:
  Abort") will be ignored and the second statement will be executed. The second 
  statement is "exit(8);" so the program will terminate.
  
17) The main function passes the "++counter" to the x. so everytime x uses the
  value of "++counter".so that in the first pass it returns a value 2.
        1 * 2 = 2
   In second pass it returns 12.
        3 * 4 = 12
   In third pass it returns 30.
        5 * 6 = 30
   After the pass 3 counter value become 6 then the while condition will fail.
 
18) While defining the expression, space is not given between identifier and
  argument. In the program the space is present between the identifier 
  "RECIPROCAL" and the argument "number". Because of this the error will
  occured.
  
19)

20) Because in the first loop the iteration uses the integer value but in the 
  second loop uses the character variable.
  The signed char have the range from -128 to 127.
  But the decimal value of (0x80) is 128. So the character variable cannot 
  hold the value 128 that's only the loop does not work.
